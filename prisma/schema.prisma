// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model User {
  id               String         @id @default(auto()) @map("_id") @db.ObjectId
  username         String         @unique
  email            String         @unique
  contactNo        String         @unique
  password         String
  role             Role
  avatar           String?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  admin            Admin?
  customer         Customer?
  verifications    Verification[]
  userStatus       UserStatus     @default(INACTIVE)
  roomsSent        Room[]         @relation("SenderRelation")
  roomsReceived    Room[]         @relation("ReceiverRelation")
  roomParticipants RoomUser[]
  chatsSent        Chat[]         @relation("SenderRelation")
  chatsReceived    Chat[]         @relation("ReceiverRelation")
  createdRooms     Room[]         @relation("CreatorRelation")
  notifications    Notification[]

  @@unique([username, email, contactNo])
  @@map("users")
}

model Verification {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  email     String
  userId    String   @db.ObjectId
  otp       Int
  user      User     @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("verifications")
}

model Admin {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String   @unique @db.ObjectId
  fullName  String
  location  String?
  user      User     @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("admins")
}

model Customer {
  id               String         @id @default(auto()) @map("_id") @db.ObjectId
  userId           String         @unique @db.ObjectId
  firstName        String?
  lastName         String?
  location         String?
  user             User           @relation(fields: [userId], references: [id])
  answers          Answer[]
  subscriptions    Subscription[]
  stripeCustomerId String?        @unique
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  Payment          Payment[]

  @@map("customers")
}

model SubscriptionPlan {
  id                   String                 @id @default(auto()) @map("_id") @db.ObjectId
  plan                 SubscribePlan          @default(MONTH) // Monthly or Yearly
  status               SubscriptionPlanStatus @default(ACTIVE)
  planName             PlanName               @default(FREE)
  description          String
  trialPeriod          Boolean                @default(true) // Is 14-day free trial included?
  price                Float                  @default(0) // Subscription price
  stripePriceId        String                 @default("") // Stripe price reference
  createdAt            DateTime               @default(now())
  updatedAt            DateTime               @updatedAt
  enrolledSubscription Subscription[]

  @@map("subscription_plans")
}

model Subscription {
  id                   String             @id @default(auto()) @map("_id") @db.ObjectId
  customerId           String             @db.ObjectId // Reference to User
  subscriptionPlanId   String             @db.ObjectId // Reference to Subscription
  subscriptionStatus   SubscriptionStatus @default(ACTIVE)
  stripeSubscriptionId String
  stripeCustomerId     String
  expiresAt            DateTime
  createdAt            DateTime           @default(now())
  cancelRequest        Boolean            @default(false)
  // Relationships
  customer             Customer           @relation(fields: [customerId], references: [id]) // Foreign Key relation to User
  subscription         SubscriptionPlan   @relation(fields: [subscriptionPlanId], references: [id]) // Foreign Key relation to Subscription
  payments             Payment[]

  @@unique([customerId, subscriptionPlanId])
  @@map("subscriptions")
}

model Payment {
  id                 String        @id @default(auto()) @map("_id") @db.ObjectId
  customerId         String        @db.ObjectId // Reference to User
  amount             Float
  currency           String
  paymentDate        DateTime
  paymentStatus      PaymentStatus
  subscriptionId     String        @db.ObjectId
  subscriptionPlanId String        @db.ObjectId
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
  customer           Customer      @relation(fields: [customerId], references: [id])
  subscription       Subscription  @relation(fields: [subscriptionId], references: [id])

  @@map("payments")
}

model Category {
  id        String     @id @default(auto()) @map("_id") @db.ObjectId
  name      String     @unique
  slug      String     @unique
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  questions Question[]

  @@map("categories")
}

model Question {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  question   String
  categoryId String   @db.ObjectId
  category   Category @relation(fields: [categoryId], references: [id])
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  answers    Answer[]

  @@map("questions")
}

model Answer {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  answer     Int
  questionId String   @db.ObjectId
  question   Question @relation(fields: [questionId], references: [id])
  customerId String   @db.ObjectId
  customer   Customer @relation(fields: [customerId], references: [id])
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@map("answers")
}

model Event {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  title       String
  slug        String   @unique
  description String
  location    String?
  date        DateTime
  startTime   String
  endTime     String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  images      Image[]

  @@map("events")
}

model Image {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  url       String
  eventId   String?  @db.ObjectId
  event     Event?   @relation(fields: [eventId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("images")
}

model Blog {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  title       String
  slug        String   @unique
  img         String
  description String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  imageId     String?  @db.ObjectId

  @@map("blogs")
}

model RoomUser {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  roomId    String   @db.ObjectId
  userId    String   @db.ObjectId
  room      Room     @relation(fields: [roomId], references: [id])
  user      User     @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, roomId])
  @@map("room_users")
}

model Notification {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String   @db.ObjectId
  title     String
  body      String
  data      String?
  read      Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id])

  @@map("notifications")
}

model Room {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  type        RoomType @default(GROUP) // Type: One-to-one or Group chat
  name        String? // Name of the group (for group chats)
  description String? // Description of the group (for group chats)  
  img         String? // Image of the group (for group chats)
  senderId    String?  @db.ObjectId
  receiverId  String?  @db.ObjectId
  creatorId   String   @db.ObjectId
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  sender   User? @relation("SenderRelation", fields: [senderId], references: [id])
  receiver User? @relation("ReceiverRelation", fields: [receiverId], references: [id])
  creator  User  @relation("CreatorRelation", fields: [creatorId], references: [id])

  participants RoomUser[] // Relationship to participants (RoomUser table)
  chat         Chat[]
  userId       String?    @db.ObjectId

  @@map("rooms")
}

model Chat {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  senderId   String   @db.ObjectId
  receiverId String?  @db.ObjectId // Nullable for group chats
  roomId     String   @db.ObjectId
  message    String
  images     String[]
  isRead     Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relationshipsb
  sender   User  @relation("SenderRelation", fields: [senderId], references: [id])
  receiver User? @relation("ReceiverRelation", fields: [receiverId], references: [id]) // Optional for group chats
  room     Room  @relation(fields: [roomId], references: [id])

  @@map("chats")
}

enum Role {
  SUPER_ADMIN
  ADMIN
  CUSTOMER
}

enum PayoutStatus {
  COMPLETED
  PROCESSED
}

enum UserStatus {
  ACTIVE
  INACTIVE
  BLOCKED
  AVAILABLE
  UNAVAILABLE
  ON_RIDE
}

enum RoomType {
  PRIVATE
  GROUP
}

enum PaymentStatus {
  REQUIRES_PAYMENT_METHOD
  REQUIRES_CONFIRMATION
  REQUIRES_ACTION
  PROCESSING
  REQUIRES_CAPTURE
  CANCELED
  SUCCEEDED
  REFUNDED
  PARTIALLY_REFUNDED
  FAILED
}

enum Currency {
  USD
  EUR
  GBP
  AUD
  CAD
  JPY
}

enum NotificationRole {
  MEMBER
  ADMIN
}

enum PlanName {
  FREE
  EDGE
  VISIONARY
  QUANTUM
}

enum MemberSubscriptionStatus {
  NONE
  ACTIVE
  EXPIRED
  PENDING
}

enum SubscriptionPlanStatus {
  ACTIVE
  INACTIVE
}

enum SubscriptionStatus {
  PENDING
  ACTIVE
  EXPIRED
  CANCELLED
  PAST_DUE
}

enum PaymentMethod {
  STRIPE
  PAYPAL
}

enum SubscribePlan {
  MONTH
  YEAR
}

enum EngagementTime {
  MORNING
  AFTERNOON
  EVENING
}

enum NotificationType {
  SUBSCRIPTION_REMINDER
  GROUP_ASSIGNMENT
  MEMBER_REGISTERED
  POST_ENGAGEMENT
  TRAINING_REQUESTED
  NEED_HELP_REQUESTED
}

enum NotificationStatus {
  UNREAD
  READ
}
